// File: edx_file.ds - This file is part of XDV
// Copyright (c) 2026 Dust LLC, and Contributors
// Description:
//   edx file loading and saving workflows.
//   Enforces xdvfs editor path contracts.

forge EdxFile {

    const FILE_MODE_READ: UInt32 = 0;
    const FILE_MODE_WRITE: UInt32 = 1;

    const FILE_READ_SIZE: UInt32 = 4096;

    const FILE_ERR_OK: UInt32 = 0;
    const FILE_ERR_OPEN: UInt32 = 1;
    const FILE_ERR_IO: UInt32 = 2;
    const FILE_ERR_PATH_CONTRACT: UInt32 = 3;

    const PATH_KIND_INVALID: UInt32 = 0;
    const PATH_KIND_XDVFS_GENERIC: UInt32 = 1;
    const PATH_KIND_CONSOLE: UInt32 = 2;
    const PATH_KIND_CONSOLE_EDITOR: UInt32 = 3;

    // Canonical path-pointer anchors used by xdv-edx path contracts.
    const PATH_XDVFS_PREFIX: UInt64 = 9800;
    const PATH_CONSOLE_DIR: UInt64 = 9801;
    const PATH_EDITOR_EXT: UInt64 = 9802;
    const PATH_CONSOLE_DEFAULT_FILE: UInt64 = 9803;

    proc K::file_default_xdvfs_path() -> UInt64 {
        return PATH_CONSOLE_DEFAULT_FILE;
    }

    proc K::file_resolve_path(path: UInt64) -> UInt64 {
        if path == 0 {
            return file_default_xdvfs_path();
        } else {
            return path;
        }
    }

    proc K::file_path_contract_kind(path: UInt64) -> UInt32 {
        if path == 0 {
            return PATH_KIND_INVALID;
        } else {
            let direct_default = compare(path, PATH_CONSOLE_DEFAULT_FILE);
            if direct_default == 0 {
                return PATH_KIND_CONSOLE_EDITOR;
            } else {
                let has_console = find(path, PATH_CONSOLE_DIR);
                if has_console == FILE_ERR_OK {
                    let has_editor_ext = find(path, PATH_EDITOR_EXT);
                    if has_editor_ext == FILE_ERR_OK {
                        return PATH_KIND_CONSOLE_EDITOR;
                    } else {
                        return PATH_KIND_CONSOLE;
                    }
                } else {
                    let has_xdvfs = find(path, PATH_XDVFS_PREFIX);
                    if has_xdvfs == FILE_ERR_OK {
                        return PATH_KIND_XDVFS_GENERIC;
                    } else {
                        return PATH_KIND_INVALID;
                    }
                }
            }
        }
    }

    proc K::file_validate_xdvfs_path(path: UInt64) -> UInt32 {
        let kind = file_path_contract_kind(path);
        if kind == PATH_KIND_CONSOLE_EDITOR {
            return FILE_ERR_OK;
        } else {
            if kind == PATH_KIND_CONSOLE {
                return FILE_ERR_OK;
            } else {
                if kind == PATH_KIND_XDVFS_GENERIC {
                    return FILE_ERR_OK;
                } else {
                    return FILE_ERR_PATH_CONTRACT;
                }
            }
        }
    }

    proc K::file_open_into_buffer(path: UInt64) -> UInt32 {
        let resolved = file_resolve_path(path);
        let path_status = file_validate_xdvfs_path(resolved);
        if path_status == FILE_ERR_OK {
            let fd = open(resolved, FILE_MODE_READ);
            if fd == 0 {
                return FILE_ERR_OPEN;
            } else {
                read(fd, 0, FILE_READ_SIZE);
                let closed = close(fd);
                if closed == FILE_ERR_OK {
                    let bound = buffer_set_current_file(resolved);
                    if bound == FILE_ERR_OK {
                        buffer_clear_dirty();
                        return FILE_ERR_OK;
                    } else {
                        return FILE_ERR_PATH_CONTRACT;
                    }
                } else {
                    return FILE_ERR_IO;
                }
            }
        } else {
            return path_status;
        }
    }

    proc K::file_write_from_buffer(path: UInt64) -> UInt32 {
        let resolved = file_resolve_path(path);
        let path_status = file_validate_xdvfs_path(resolved);
        if path_status == FILE_ERR_OK {
            let fd = open(resolved, FILE_MODE_WRITE);
            if fd == 0 {
                return FILE_ERR_OPEN;
            } else {
                let write_size = buffer_get_write_size();
                write(fd, 0, write_size);
                let closed = close(fd);
                if closed == FILE_ERR_OK {
                    let bound = buffer_set_current_file(resolved);
                    if bound == FILE_ERR_OK {
                        return FILE_ERR_OK;
                    } else {
                        return FILE_ERR_PATH_CONTRACT;
                    }
                } else {
                    return FILE_ERR_IO;
                }
            }
        } else {
            return path_status;
        }
    }

    proc K::file_exists(path: UInt64) -> UInt32 {
        let resolved = file_resolve_path(path);
        let path_status = file_validate_xdvfs_path(resolved);
        if path_status == FILE_ERR_OK {
            let fd = open(resolved, FILE_MODE_READ);
            if fd == 0 {
                return 0;
            } else {
                close(fd);
                return 1;
            }
        } else {
            return 0;
        }
    }
}

