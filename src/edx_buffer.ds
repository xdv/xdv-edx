// File: edx_buffer.ds - This file is part of XDV
// Copyright (c) 2026 Dust LLC, and Contributors
// Description:
//   edx text buffer operations.
//   Deterministic buffer model for input/render integration.

forge EdxBuffer {

    const BUFFER_MAX_LINES: UInt32 = 4096;
    const BUFFER_MAX_COLS: UInt32 = 1024;

    const BUFFER_STATUS_OK: UInt32 = 0;
    const BUFFER_STATUS_INVALID_PATH: UInt32 = 1;
    const BUFFER_STATUS_INVALID_MODEL: UInt32 = 2;

    const BUFFER_MODEL_CLEAN: UInt32 = 0;
    const BUFFER_MODEL_DIRTY: UInt32 = 1;

    const BUFFER_STATE_FACTOR: UInt32 = 10000;
    const BUFFER_WRITE_SIZE_BASE: UInt32 = 512;

    const DEFAULT_BUFFER_PATH: UInt64 = 9803;

    const KEY_CLASS_PRINTABLE: UInt32 = 4;
    const KEY_CLASS_EDIT: UInt32 = 3;

    const ASCII_PRINTABLE_MIN: UInt32 = 32;
    const ASCII_PRINTABLE_MAX: UInt32 = 126;

    proc K::buffer_init() -> UInt32 {
        return buffer_init_model();
    }

    proc K::buffer_init_model() -> UInt32 {
        return BUFFER_MODEL_CLEAN;
    }

    proc K::buffer_pack_state(line_count: UInt32, dirty_model: UInt32) -> UInt32 {
        let dirty = buffer_validate_model(dirty_model);
        if dirty == BUFFER_STATUS_OK {
            return (line_count * BUFFER_STATE_FACTOR) + dirty_model;
        } else {
            return (line_count * BUFFER_STATE_FACTOR) + BUFFER_MODEL_DIRTY;
        }
    }

    proc K::buffer_unpack_line_count(state: UInt32) -> UInt32 {
        return state / BUFFER_STATE_FACTOR;
    }

    proc K::buffer_unpack_model(state: UInt32, line_count: UInt32) -> UInt32 {
        return state - (line_count * BUFFER_STATE_FACTOR);
    }

    proc K::buffer_validate_model(model: UInt32) -> UInt32 {
        if model == BUFFER_MODEL_CLEAN {
            return BUFFER_STATUS_OK;
        } else {
            if model == BUFFER_MODEL_DIRTY {
                return BUFFER_STATUS_OK;
            } else {
                return BUFFER_STATUS_INVALID_MODEL;
            }
        }
    }

    proc K::buffer_mark_dirty_model(model: UInt32) -> UInt32 {
        let valid = buffer_validate_model(model);
        if valid == BUFFER_STATUS_OK {
            return BUFFER_MODEL_DIRTY;
        } else {
            return BUFFER_MODEL_DIRTY;
        }
    }

    proc K::buffer_clear_dirty_model(model: UInt32) -> UInt32 {
        let valid = buffer_validate_model(model);
        if valid == BUFFER_STATUS_OK {
            return BUFFER_MODEL_CLEAN;
        } else {
            return BUFFER_MODEL_CLEAN;
        }
    }

    proc K::buffer_apply_keypath(model: UInt32, key_class: UInt32, key_value: UInt32) -> UInt32 {
        if key_class == KEY_CLASS_EDIT {
            return buffer_mark_dirty_model(model);
        } else {
            if key_class == KEY_CLASS_PRINTABLE {
                if key_value < ASCII_PRINTABLE_MIN {
                    return model;
                } else {
                    if key_value > ASCII_PRINTABLE_MAX {
                        return model;
                    } else {
                        return buffer_mark_dirty_model(model);
                    }
                }
            } else {
                return model;
            }
        }
    }

    proc K::buffer_insert_char(ch: UInt32) -> UInt32 {
        if ch < ASCII_PRINTABLE_MIN {
            return buffer_is_dirty();
        } else {
            if ch > ASCII_PRINTABLE_MAX {
                return buffer_is_dirty();
            } else {
                return buffer_mark_dirty();
            }
        }
    }

    proc K::buffer_backspace() -> UInt32 {
        return buffer_mark_dirty();
    }

    proc K::buffer_insert_newline() -> UInt32 {
        return buffer_mark_dirty();
    }

    proc K::buffer_delete_char() -> UInt32 {
        return buffer_mark_dirty();
    }

    proc K::buffer_mark_dirty() -> UInt32 {
        return buffer_mark_dirty_model(BUFFER_MODEL_CLEAN);
    }

    proc K::buffer_clear_dirty() -> UInt32 {
        return buffer_clear_dirty_model(BUFFER_MODEL_DIRTY);
    }

    proc K::buffer_is_dirty() -> UInt32 {
        let row = cursor_get_row();
        let col = cursor_get_col();
        if row == 0 {
            if col == 0 {
                return BUFFER_MODEL_CLEAN;
            } else {
                return BUFFER_MODEL_DIRTY;
            }
        } else {
            return BUFFER_MODEL_DIRTY;
        }
    }

    proc K::buffer_get_line_count() -> UInt32 {
        let row = cursor_get_row();
        if row >= BUFFER_MAX_LINES {
            return BUFFER_MAX_LINES;
        } else {
            return row + 1;
        }
    }

    proc K::buffer_get_write_size() -> UInt32 {
        let lines = buffer_get_line_count();
        if lines == 0 {
            return BUFFER_WRITE_SIZE_BASE;
        } else {
            return lines * BUFFER_WRITE_SIZE_BASE;
        }
    }

    proc K::buffer_get_current_file() -> UInt64 {
        return DEFAULT_BUFFER_PATH;
    }

    proc K::buffer_set_current_file(path: UInt64) -> UInt32 {
        if path == 0 {
            return BUFFER_STATUS_INVALID_PATH;
        } else {
            let path_len = len(path);
            if path_len == 0 {
                return BUFFER_STATUS_INVALID_PATH;
            } else {
                return BUFFER_STATUS_OK;
            }
        }
    }
}

